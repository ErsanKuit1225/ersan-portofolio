const {
  breakExternalTableId,
  generateRowIdField,
  breakRowIdField,
} = require("../../../integrations/utils")
const { FieldTypes } = require("../../../constants")
const { cloneDeep } = require("lodash/fp")

function basicProcessing(row, table) {
  const thisRow = {}
  // filter the row down to what is actually the row (not joined)
  for (let fieldName of Object.keys(table.schema)) {
    thisRow[fieldName] = row[fieldName]
  }
  thisRow._id = exports.generateIdForRow(row, table)
  thisRow.tableId = table._id
  thisRow._rev = "rev"
  return thisRow
}

function isMany(field) {
  return field.relationshipType.split("-")[0] === "many"
}

exports.inputProcessing = (row, table, allTables) => {
  if (!row) {
    return { row, manyRelationships: [] }
  }
  let newRow = {},
    manyRelationships = []
  for (let [key, field] of Object.entries(table.schema)) {
    // if set already, or not set just skip it
    if (!row[key] || newRow[key]) {
      continue
    }
    // if its not a link then just copy it over
    if (field.type !== FieldTypes.LINK) {
      newRow[key] = row[key]
      continue
    }
    const { tableName: linkTableName } = breakExternalTableId(field.tableId)
    // table has to exist for many to many
    if (!allTables[linkTableName]) {
      continue
    }
    const linkTable = allTables[linkTableName]
    if (!isMany(field)) {
      // we don't really support composite keys for relationships, this is why [0] is used
      newRow[field.foreignKey || linkTable.primary] = breakRowIdField(
        row[key][0]
      )[0]
    } else {
      // we're not inserting a doc, will be a bunch of update calls
      const isUpdate = !field.through
      const thisKey = isUpdate ? "id" : linkTable.primary
      const otherKey = isUpdate ? field.foreignKey : table.primary
      row[key].map(relationship => {
        // we don't really support composite keys for relationships, this is why [0] is used
        manyRelationships.push({
          tableId: field.through || field.tableId,
          isUpdate,
          [thisKey]: breakRowIdField(relationship)[0],
          // leave the ID for enrichment later
          [otherKey]: `{{ ${table.primary} }}`,
        })
      })
    }
  }
  // we return the relationships that may need to be created in the through table
  // we do this so that if the ID is generated by the DB it can be inserted
  // after the fact
  return { row: newRow, manyRelationships }
}

exports.generateIdForRow = (row, table) => {
  if (!row) {
    return null
  }
  const primary = table.primary
  // build id array
  let idParts = []
  for (let field of primary) {
    if (row[field]) {
      idParts.push(row[field])
    }
  }
  if (idParts.length === 0) {
    return null
  }
  return generateRowIdField(idParts)
}

exports.updateRelationshipColumns = (row, rows, relationships, allTables) => {
  const columns = {}
  for (let relationship of relationships) {
    const linkedTable = allTables[relationship.tableName]
    if (!linkedTable) {
      continue
    }
    let linked = basicProcessing(row, linkedTable)
    if (!linked._id) {
      continue
    }
    // if not returning full docs then get the minimal links out
    const display = linkedTable.primaryDisplay
    linked = {
      primaryDisplay: display ? linked[display] : undefined,
      _id: linked._id,
    }
    columns[relationship.column] = linked
  }
  for (let [column, related] of Object.entries(columns)) {
    if (!Array.isArray(rows[row._id][column])) {
      rows[row._id][column] = []
    }
    // make sure relationship hasn't been found already
    if (!rows[row._id][column].find(relation => relation._id === related._id)) {
      rows[row._id][column].push(related)
    }
  }
  return rows
}

exports.outputProcessing = (rows, table, relationships, allTables) => {
  // if no rows this is what is returned? Might be PG only
  if (rows[0].read === true) {
    return []
  }
  let finalRows = {}
  for (let row of rows) {
    row._id = exports.generateIdForRow(row, table)
    // this is a relationship of some sort
    if (finalRows[row._id]) {
      finalRows = exports.updateRelationshipColumns(
        row,
        finalRows,
        relationships,
        allTables
      )
      continue
    }
    const thisRow = basicProcessing(row, table)
    finalRows[thisRow._id] = thisRow
    // do this at end once its been added to the final rows
    finalRows = exports.updateRelationshipColumns(
      row,
      finalRows,
      relationships,
      allTables
    )
  }
  return Object.values(finalRows)
}

/**
 * This function is a bit crazy, but the exact purpose of it is to protect against the scenario in which
 * you have column overlap in relationships, e.g. we join a few different tables and they all have the
 * concept of an ID, but for some of them it will be null (if they say don't have a relationship).
 * Creating the specific list of fields that we desire, and excluding the ones that are no use to us
 * is more performant and has the added benefit of protecting against this scenario.
 * @param {Object} table The table we are retrieving fields for.
 * @param {Object[]} allTables All of the tables that exist in the external data source, this is
 * needed to work out what is needed from other tables based on relationships.
 * @return {string[]} A list of fields like ["products.productid"] which can be used for an SQL select.
 */
exports.buildFields = (table, allTables) => {
  function extractNonLinkFieldNames(table, existing = []) {
    return Object.entries(table.schema)
      .filter(
        column =>
          column[1].type !== FieldTypes.LINK &&
          !existing.find(field => field.includes(column[0]))
      )
      .map(column => `${table.name}.${column[0]}`)
  }
  let fields = extractNonLinkFieldNames(table)
  for (let field of Object.values(table.schema)) {
    if (field.type !== FieldTypes.LINK) {
      continue
    }
    const { tableName: linkTableName } = breakExternalTableId(field.tableId)
    const linkTable = allTables[linkTableName]
    if (linkTable) {
      const linkedFields = extractNonLinkFieldNames(linkTable, fields)
      fields = fields.concat(linkedFields)
    }
  }
  return fields
}

exports.buildFilters = (id, filters, table) => {
  const primary = table.primary
  // if passed in array need to copy for shifting etc
  let idCopy = cloneDeep(id)
  if (filters) {
    // need to map over the filters and make sure the _id field isn't present
    for (let filter of Object.values(filters)) {
      if (filter._id) {
        const parts = breakRowIdField(filter._id)
        for (let field of primary) {
          filter[field] = parts.shift()
        }
      }
      // make sure this field doesn't exist on any filter
      delete filter._id
    }
  }
  // there is no id, just use the user provided filters
  if (!idCopy || !table) {
    return filters
  }
  // if used as URL parameter it will have been joined
  if (!Array.isArray(idCopy)) {
    idCopy = breakRowIdField(idCopy)
  }
  const equal = {}
  for (let field of primary) {
    // work through the ID and get the parts
    equal[field] = idCopy.shift()
  }
  return {
    equal,
  }
}

exports.buildRelationships = (table, allTables) => {
  const relationships = []
  for (let [fieldName, field] of Object.entries(table.schema)) {
    if (field.type !== FieldTypes.LINK) {
      continue
    }
    const { tableName: linkTableName } = breakExternalTableId(field.tableId)
    // no table to link to, this is not a valid relationships
    if (!allTables[linkTableName]) {
      continue
    }
    const linkTable = allTables[linkTableName]
    const definition = {
      // if no foreign key specified then use the name of the field in other table
      from: field.foreignKey || table.primary[0],
      to: field.fieldName,
      tableName: linkTableName,
      through: undefined,
      // need to specify where to put this back into
      column: fieldName,
    }
    if (field.through) {
      const { tableName: throughTableName } = breakExternalTableId(
        field.through
      )
      definition.through = throughTableName
      // don't support composite keys for relationships
      definition.from = table.primary[0]
      definition.to = linkTable.primary[0]
    }
    relationships.push(definition)
  }
  return relationships
}
